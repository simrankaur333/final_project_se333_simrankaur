import os
import subprocess
from pathlib import Path
from fastmcp import FastMCP

import re
import xml.etree.ElementTree as ET

mcp = FastMCP()

# =========================
# CONFIGURATION
# =========================

JAVA_SRC_DIR = Path("codebase/src/main/java")
TEST_OUTPUT_DIR = Path("codebase/src/test/java/generated_tests")
JACOCO_XML = Path("codebase/target/site/jacoco/jacoco.xml")

TEST_OUTPUT_DIR.mkdir(parents=True, exist_ok=True)


# =========================
# HELPER UTILS
# =========================

def run_cmd(command):
    """Run a terminal command and return output or error."""
    try:
        result = subprocess.run(
            command, shell=True, capture_output=True, text=True
        )
        if result.returncode != 0:
            return f"ERROR:\n{result.stderr}"
        return result.stdout
    except Exception as e:
        return f"Failed to run command: {e}"


# =========================
# TEST GENERATION LOGIC
# =========================

def generate_test_method(class_name, method_name, return_type):
    default_val = {
        "int": "0",
        "boolean": "true",
        "double": "0.0",
        "float": "0.0f",
        "String": '"test"'
    }.get(return_type, "null")

    return f"""
    @Test
    public void test_{method_name}() {{
        {class_name} obj = new {class_name}();
        {return_type} result = obj.{method_name}();
        assertNotNull(result); 
    }}
    """


@mcp.tool()
def generate_junit_tests() -> str:
    """
    Analyze Java source code and generate JUnit test files.
    """
    import re
    
    java_files = list(Path(JAVA_SRC_DIR).rglob("*.java"))
    if not java_files:
        return "No Java files found."
    
    for file_path in java_files:
        # Use utf-8 with error handling to avoid decode errors
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                code = f.read()
        except Exception as e:
            print(f"Skipping {file_path}: {e}")
            continue
        
        # Find classes
        class_matches = re.findall(r"class (\w+)", code)
        for class_name in class_matches:
            # Find public methods (simple regex)
            methods = re.findall(r"public (\w+) (\w+)\(", code)
            test_methods = []
            for return_type, method_name in methods:
                test_methods.append(generate_test_method(class_name, method_name, return_type))
            
            if test_methods:
                test_class_code = f"""
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class Test{class_name} {{
{''.join(test_methods)}
}}
"""
                test_file_path = Path(TEST_OUTPUT_DIR) / f"Test{class_name}.java"
                with open(test_file_path, "w", encoding="utf-8") as f:
                    f.write(test_class_code)
    
    return f"Generated tests for {len(java_files)} Java files in {TEST_OUTPUT_DIR}."


# =========================
# COVERAGE ANALYSIS
# =========================

@mcp.tool()
def analyze_coverage() -> str:
    """Parse JaCoCo test coverage report."""
    if not JACOCO_XML.exists():
        return "No JaCoCo report found. Run `mvn test` to generate one."

    tree = ET.parse(JACOCO_XML)
    root = tree.getroot()
    summary = {}

    for pkg in root.findall(".//package"):
        for cls in pkg.findall("class"):
            name = cls.attrib["name"]
            lines = cls.findall("line")

            covered = sum(1 for l in lines if int(l.attrib.get("ci", 0)) > 0)
            total = len(lines)

            summary[name] = f"{covered}/{total}"

    return f"Coverage summary:\n{summary}"


# =========================
# GIT AUTOMATION TOOLS (PHASE 3)
# =========================

@mcp.tool()
def git_status() -> str:
    """Return Git status including staged/unstaged/conflicts."""
    return run_cmd("git status --untracked-files")


@mcp.tool()
def git_add_all() -> str:
    """
    Stage all files EXCEPT:
    - target/
    - temporary files
    """
    run_cmd("git add -A")

    # Unstage unwanted files
    run_cmd("git reset target/ 2>/dev/null")

    return run_cmd("git status --short")


@mcp.tool()
def git_commit(message: str) -> str:
    """Create a standardized commit with optional coverage report."""
    # Auto-append coverage numbers
    cov = analyze_coverage()
    full_msg = f"{message}\n\nCoverage Report:\n{cov}"

    # Write temporary message file
    msg_file = ".commit_msg.txt"
    Path(msg_file).write_text(full_msg, encoding="utf-8")

    result = run_cmd(f"git commit -F {msg_file}")
    Path(msg_file).unlink(missing_ok=True)
    return result


@mcp.tool()
def git_push(remote: str = "origin") -> str:
    """Push current branch to remote."""
    return run_cmd(f"git push {remote}")


@mcp.tool()
def git_pull_request(base: str = "main", title: str = "Automated PR", body: str = "Generated by MCP Agent") -> str:
    """
    Create a pull request using the GitHub CLI.
    Requires installed GitHub CLI and authenticated user.
    """
    pr_cmd = f'gh pr create --base "{base}" --title "{title}" --body "{body}"'
    return run_cmd(pr_cmd)


# =========================
# ENTRY POINT
# =========================

if __name__ == "__main__":
    mcp.run(transport="sse")
